// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: toxicities.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addToxicity = `-- name: AddToxicity :one
INSERT INTO toxicities (title, category, description)
VALUES ($1, $2, $3)
RETURNING id, created_at, updated_at, title, category, description
`

type AddToxicityParams struct {
	Title       string `json:"title"`
	Category    string `json:"category"`
	Description string `json:"description"`
}

func (q *Queries) AddToxicity(ctx context.Context, arg AddToxicityParams) (Toxicity, error) {
	row := q.db.QueryRowContext(ctx, addToxicity, arg.Title, arg.Category, arg.Description)
	var i Toxicity
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const addToxicityGrade = `-- name: AddToxicityGrade :one
INSERT INTO toxicity_grades (grade, description, toxicity_id)
VALUES ($1, $2, $3)
RETURNING id, created_at, updated_at, grade, description, toxicity_id
`

type AddToxicityGradeParams struct {
	Grade       GradeEnum `json:"grade"`
	Description string    `json:"description"`
	ToxicityID  uuid.UUID `json:"toxicity_id"`
}

func (q *Queries) AddToxicityGrade(ctx context.Context, arg AddToxicityGradeParams) (ToxicityGrade, error) {
	row := q.db.QueryRowContext(ctx, addToxicityGrade, arg.Grade, arg.Description, arg.ToxicityID)
	var i ToxicityGrade
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Grade,
		&i.Description,
		&i.ToxicityID,
	)
	return i, err
}

const addToxicityModification = `-- name: AddToxicityModification :one
INSERT INTO protocol_tox_modifications (adjustment, toxicity_grade_id, protocol_id)
VALUES ($1, $2, $3)
RETURNING id, created_at, updated_at, adjustment, toxicity_grade_id, protocol_id
`

type AddToxicityModificationParams struct {
	Adjustment      string    `json:"adjustment"`
	ToxicityGradeID uuid.UUID `json:"toxicity_grade_id"`
	ProtocolID      uuid.UUID `json:"protocol_id"`
}

func (q *Queries) AddToxicityModification(ctx context.Context, arg AddToxicityModificationParams) (ProtocolToxModification, error) {
	row := q.db.QueryRowContext(ctx, addToxicityModification, arg.Adjustment, arg.ToxicityGradeID, arg.ProtocolID)
	var i ProtocolToxModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Adjustment,
		&i.ToxicityGradeID,
		&i.ProtocolID,
	)
	return i, err
}

const deleteProtocolToxModificationsByProtocolAndToxicity = `-- name: DeleteProtocolToxModificationsByProtocolAndToxicity :exec
DELETE FROM protocol_tox_modifications ptm
USING toxicity_grades tg
WHERE ptm.toxicity_grade_id = tg.id
  AND ptm.protocol_id = $1
  AND tg.toxicity_id = $2
`

type DeleteProtocolToxModificationsByProtocolAndToxicityParams struct {
	ProtocolID uuid.UUID `json:"protocol_id"`
	ToxicityID uuid.UUID `json:"toxicity_id"`
}

func (q *Queries) DeleteProtocolToxModificationsByProtocolAndToxicity(ctx context.Context, arg DeleteProtocolToxModificationsByProtocolAndToxicityParams) error {
	_, err := q.db.ExecContext(ctx, deleteProtocolToxModificationsByProtocolAndToxicity, arg.ProtocolID, arg.ToxicityID)
	return err
}

const getToxicitiesWithGrades = `-- name: GetToxicitiesWithGrades :many
SELECT
    t.id AS id,
    t.created_at AS created_at,
    t.updated_at AS updated_at,
    t.title AS title,
    t.category AS category,
    t.description AS description,    
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', tg.id,
                'created_at', tg.created_at,
                'updated_at', tg.updated_at,
                'grade', tg.grade,
                'description', tg.description
            )
        ) FILTER (WHERE tg.id IS NOT NULL),
        '[]'
    )::jsonb AS grades
FROM
    toxicities t
LEFT JOIN
    toxicity_grades tg ON t.id = tg.toxicity_id
GROUP BY
    t.id, t.created_at, t.updated_at, t.title, t.category, t.description
`

type GetToxicitiesWithGradesRow struct {
	ID          uuid.UUID       `json:"id"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	Title       string          `json:"title"`
	Category    string          `json:"category"`
	Description string          `json:"description"`
	Grades      json.RawMessage `json:"grades"`
}

func (q *Queries) GetToxicitiesWithGrades(ctx context.Context) ([]GetToxicitiesWithGradesRow, error) {
	rows, err := q.db.QueryContext(ctx, getToxicitiesWithGrades)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetToxicitiesWithGradesRow{}
	for rows.Next() {
		var i GetToxicitiesWithGradesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Grades,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToxicitiesWithGradesAndAdjustments = `-- name: GetToxicitiesWithGradesAndAdjustments :many
SELECT 
    t.id,
    t.created_at,
    t.updated_at,
    t.title,
    t.category,
    t.description,
    COALESCE(
    JSONb_AGG(
        JSONb_BUILD_OBJECT(
            'id', tg.id,
            'created_at', tg.created_at,
            'updated_at', tg.updated_at,
            'grade', tg.grade,
            'description', tg.description,
            'adjustment', ptm.adjustment,
            'adjustment_id', ptm.id
        ) 
        ORDER BY tg.grade
        ) FILTER (WHERE tg.id IS NOT NULL),
        '[]'
    )::jsonb as grades
FROM toxicities t
LEFT JOIN toxicity_grades tg ON t.id = tg.toxicity_id
LEFT JOIN protocol_tox_modifications ptm ON tg.id = ptm.toxicity_grade_id AND ptm.protocol_id = $1
GROUP BY t.id, t.created_at, t.updated_at, t.title, t.category, t.description
ORDER BY t.title
`

type GetToxicitiesWithGradesAndAdjustmentsRow struct {
	ID          uuid.UUID       `json:"id"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	Title       string          `json:"title"`
	Category    string          `json:"category"`
	Description string          `json:"description"`
	Grades      json.RawMessage `json:"grades"`
}

func (q *Queries) GetToxicitiesWithGradesAndAdjustments(ctx context.Context, protocolID uuid.UUID) ([]GetToxicitiesWithGradesAndAdjustmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getToxicitiesWithGradesAndAdjustments, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetToxicitiesWithGradesAndAdjustmentsRow{}
	for rows.Next() {
		var i GetToxicitiesWithGradesAndAdjustmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Grades,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToxicitiesWithGradesAndAdjustmentsByProtocol = `-- name: GetToxicitiesWithGradesAndAdjustmentsByProtocol :many
SELECT 
    t.id,
    t.created_at,
    t.updated_at,
    t.title,
    t.category,
    t.description,
    COALESCE(
    JSONb_AGG(
        JSONb_BUILD_OBJECT(
            'id', tg.id,
            'created_at', tg.created_at,
            'updated_at', tg.updated_at,
            'grade', tg.grade,
            'description', tg.description,
            'adjustment', ptm.adjustment,
            'adjustment_id', ptm.id
        ) 
        ORDER BY tg.grade
        ) FILTER (WHERE tg.id IS NOT NULL),
        '[]'
    )::jsonb as grades
FROM toxicities t
LEFT JOIN toxicity_grades tg ON tg.toxicity_id = t.id
LEFT JOIN protocol_tox_modifications ptm 
  ON ptm.toxicity_grade_id = tg.id 
  AND ptm.protocol_id = $1
WHERE EXISTS (
  SELECT 1 FROM protocol_tox_modifications ptm2
  JOIN toxicity_grades tg2 ON ptm2.toxicity_grade_id = tg2.id
  WHERE tg2.toxicity_id = t.id AND ptm2.protocol_id = $1
)
GROUP BY t.id
`

type GetToxicitiesWithGradesAndAdjustmentsByProtocolRow struct {
	ID          uuid.UUID       `json:"id"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	Title       string          `json:"title"`
	Category    string          `json:"category"`
	Description string          `json:"description"`
	Grades      json.RawMessage `json:"grades"`
}

func (q *Queries) GetToxicitiesWithGradesAndAdjustmentsByProtocol(ctx context.Context, protocolID uuid.UUID) ([]GetToxicitiesWithGradesAndAdjustmentsByProtocolRow, error) {
	rows, err := q.db.QueryContext(ctx, getToxicitiesWithGradesAndAdjustmentsByProtocol, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetToxicitiesWithGradesAndAdjustmentsByProtocolRow{}
	for rows.Next() {
		var i GetToxicitiesWithGradesAndAdjustmentsByProtocolRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Category,
			&i.Description,
			&i.Grades,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToxicityByID = `-- name: GetToxicityByID :one
SELECT
    t.id AS id,
    t.created_at AS created_at,
    t.updated_at AS updated_at,
    t.title AS title,
    t.category AS category,
    t.description AS description,
    COALESCE(
        jsonb_agg(
            jsonb_build_object(
                'id', tg.id,
                'created_at',tg.created_at,
                'updated_at',tg.updated_at,
                'grade', tg.grade,
                'description', tg.description
            )
        ) FILTER (WHERE tg.id IS NOT NULL),
        '[]'
    )::jsonb AS grades
FROM
    toxicities t
LEFT JOIN
    toxicity_grades tg ON t.id = tg.toxicity_id
WHERE t.id = $1
GROUP BY
    t.id, t.created_at, t.updated_at, t.title, t.category, t.description
`

type GetToxicityByIDRow struct {
	ID          uuid.UUID       `json:"id"`
	CreatedAt   time.Time       `json:"created_at"`
	UpdatedAt   time.Time       `json:"updated_at"`
	Title       string          `json:"title"`
	Category    string          `json:"category"`
	Description string          `json:"description"`
	Grades      json.RawMessage `json:"grades"`
}

func (q *Queries) GetToxicityByID(ctx context.Context, id uuid.UUID) (GetToxicityByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getToxicityByID, id)
	var i GetToxicityByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Category,
		&i.Description,
		&i.Grades,
	)
	return i, err
}

const getToxicityByName = `-- name: GetToxicityByName :one
SELECT id, created_at, updated_at, title, category, description FROM toxicities
WHERE title = $1
`

func (q *Queries) GetToxicityByName(ctx context.Context, title string) (Toxicity, error) {
	row := q.db.QueryRowContext(ctx, getToxicityByName, title)
	var i Toxicity
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const getToxicityGrade = `-- name: GetToxicityGrade :one
SELECT id, created_at, updated_at, grade, description, toxicity_id FROM toxicity_grades
WHERE id = $1
`

func (q *Queries) GetToxicityGrade(ctx context.Context, id uuid.UUID) (ToxicityGrade, error) {
	row := q.db.QueryRowContext(ctx, getToxicityGrade, id)
	var i ToxicityGrade
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Grade,
		&i.Description,
		&i.ToxicityID,
	)
	return i, err
}

const getToxicityGradeByGrade = `-- name: GetToxicityGradeByGrade :one
SELECT id, created_at, updated_at, grade, description, toxicity_id FROM toxicity_grades
WHERE grade = $1 AND toxicity_id = $2
`

type GetToxicityGradeByGradeParams struct {
	Grade      GradeEnum `json:"grade"`
	ToxicityID uuid.UUID `json:"toxicity_id"`
}

func (q *Queries) GetToxicityGradeByGrade(ctx context.Context, arg GetToxicityGradeByGradeParams) (ToxicityGrade, error) {
	row := q.db.QueryRowContext(ctx, getToxicityGradeByGrade, arg.Grade, arg.ToxicityID)
	var i ToxicityGrade
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Grade,
		&i.Description,
		&i.ToxicityID,
	)
	return i, err
}

const getToxicityModificationsByTreatment = `-- name: GetToxicityModificationsByTreatment :many
SELECT id, created_at, updated_at, adjustment, toxicity_grade_id, protocol_id FROM protocol_tox_modifications
WHERE protocol_id = $1
`

func (q *Queries) GetToxicityModificationsByTreatment(ctx context.Context, protocolID uuid.UUID) ([]ProtocolToxModification, error) {
	rows, err := q.db.QueryContext(ctx, getToxicityModificationsByTreatment, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProtocolToxModification{}
	for rows.Next() {
		var i ProtocolToxModification
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Adjustment,
			&i.ToxicityGradeID,
			&i.ProtocolID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeToxicity = `-- name: RemoveToxicity :exec
DELETE FROM toxicities
WHERE id = $1
`

func (q *Queries) RemoveToxicity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeToxicity, id)
	return err
}

const removeToxicityGrade = `-- name: RemoveToxicityGrade :exec
DELETE FROM toxicity_grades
WHERE id = $1
`

func (q *Queries) RemoveToxicityGrade(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeToxicityGrade, id)
	return err
}

const removeToxicityModification = `-- name: RemoveToxicityModification :exec
DELETE FROM protocol_tox_modifications
WHERE id = $1
`

func (q *Queries) RemoveToxicityModification(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeToxicityModification, id)
	return err
}

const updateToxicity = `-- name: UpdateToxicity :one
UPDATE toxicities
SET
    updated_at = NOW(),
    title = $2,
    category = $3,
    description = $4
WHERE id = $1
RETURNING id, created_at, updated_at, title, category, description
`

type UpdateToxicityParams struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Category    string    `json:"category"`
	Description string    `json:"description"`
}

func (q *Queries) UpdateToxicity(ctx context.Context, arg UpdateToxicityParams) (Toxicity, error) {
	row := q.db.QueryRowContext(ctx, updateToxicity,
		arg.ID,
		arg.Title,
		arg.Category,
		arg.Description,
	)
	var i Toxicity
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const updateToxicityGrade = `-- name: UpdateToxicityGrade :one
UPDATE toxicity_grades
SET
    updated_at = NOW(),
    grade = $2,
    description = $3,
    toxicity_id = $4
WHERE id = $1
RETURNING id, created_at, updated_at, grade, description, toxicity_id
`

type UpdateToxicityGradeParams struct {
	ID          uuid.UUID `json:"id"`
	Grade       GradeEnum `json:"grade"`
	Description string    `json:"description"`
	ToxicityID  uuid.UUID `json:"toxicity_id"`
}

func (q *Queries) UpdateToxicityGrade(ctx context.Context, arg UpdateToxicityGradeParams) (ToxicityGrade, error) {
	row := q.db.QueryRowContext(ctx, updateToxicityGrade,
		arg.ID,
		arg.Grade,
		arg.Description,
		arg.ToxicityID,
	)
	var i ToxicityGrade
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Grade,
		&i.Description,
		&i.ToxicityID,
	)
	return i, err
}

const updateToxicityModification = `-- name: UpdateToxicityModification :one
UPDATE protocol_tox_modifications
SET
    updated_at = NOW(),
    adjustment = $2,
    toxicity_grade_id = $3,
    protocol_id = $4
WHERE id = $1
RETURNING id, created_at, updated_at, adjustment, toxicity_grade_id, protocol_id
`

type UpdateToxicityModificationParams struct {
	ID              uuid.UUID `json:"id"`
	Adjustment      string    `json:"adjustment"`
	ToxicityGradeID uuid.UUID `json:"toxicity_grade_id"`
	ProtocolID      uuid.UUID `json:"protocol_id"`
}

func (q *Queries) UpdateToxicityModification(ctx context.Context, arg UpdateToxicityModificationParams) (ProtocolToxModification, error) {
	row := q.db.QueryRowContext(ctx, updateToxicityModification,
		arg.ID,
		arg.Adjustment,
		arg.ToxicityGradeID,
		arg.ProtocolID,
	)
	var i ProtocolToxModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Adjustment,
		&i.ToxicityGradeID,
		&i.ProtocolID,
	)
	return i, err
}

const upsertToxicity = `-- name: UpsertToxicity :one
INSERT INTO toxicities (id,title,category,description)
VALUES (
    $1,
    $2,
    $3,
    $4    
)
ON CONFLICT (id) DO UPDATE SET
    title = EXCLUDED.title,
    category = EXCLUDED.category,
    description = EXCLUDED.description,
    updated_at = NOW()
RETURNING id, created_at, updated_at, title, category, description
`

type UpsertToxicityParams struct {
	ID          uuid.UUID `json:"id"`
	Title       string    `json:"title"`
	Category    string    `json:"category"`
	Description string    `json:"description"`
}

func (q *Queries) UpsertToxicity(ctx context.Context, arg UpsertToxicityParams) (Toxicity, error) {
	row := q.db.QueryRowContext(ctx, upsertToxicity,
		arg.ID,
		arg.Title,
		arg.Category,
		arg.Description,
	)
	var i Toxicity
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Category,
		&i.Description,
	)
	return i, err
}

const upsertToxicityModification = `-- name: UpsertToxicityModification :exec
WITH input_data AS (
    SELECT 
        unnest($2::uuid[]) AS id,
        unnest($3::uuid[]) AS grade_id,
        unnest($4::text[]) AS adjustment
)
INSERT INTO protocol_tox_modifications (
    id, 
    toxicity_grade_id, 
    protocol_id, 
    adjustment
)
SELECT
    id,
    grade_id,
    $1::uuid,
    adjustment
FROM input_data
ON CONFLICT (id) DO UPDATE SET
    toxicity_grade_id = EXCLUDED.toxicity_grade_id,
    adjustment = EXCLUDED.adjustment,
    updated_at = NOW()
`

type UpsertToxicityModificationParams struct {
	ProtocolID uuid.UUID   `json:"protocol_id"`
	ID         []uuid.UUID `json:"id"`
	GradeIds   []uuid.UUID `json:"grade_ids"`
	Adjustment []string    `json:"adjustment"`
}

func (q *Queries) UpsertToxicityModification(ctx context.Context, arg UpsertToxicityModificationParams) error {
	_, err := q.db.ExecContext(ctx, upsertToxicityModification,
		arg.ProtocolID,
		pq.Array(arg.ID),
		pq.Array(arg.GradeIds),
		pq.Array(arg.Adjustment),
	)
	return err
}

const upsertToxicityWithGrades = `-- name: UpsertToxicityWithGrades :exec
WITH upsert_toxicity AS (
  INSERT INTO toxicities (id, title, category, description)
  VALUES ($1, $2, $3, $4)
  ON CONFLICT (id) DO UPDATE
  SET title = EXCLUDED.title,
      category = EXCLUDED.category,
      description = EXCLUDED.description,
      updated_at = NOW()
  RETURNING id
), upsert_grades AS (
  INSERT INTO toxicity_grades (id, grade, description, toxicity_id)
  SELECT 
    unnest($5::uuid[]),
    unnest($6::grade_enum[]),
    unnest($7::text[]),
    (SELECT id FROM upsert_toxicity)
  ON CONFLICT (id) DO UPDATE
  SET grade = EXCLUDED.grade,
      description = EXCLUDED.description,
      updated_at = NOW()
)
SELECT 1
`

type UpsertToxicityWithGradesParams struct {
	ID               uuid.UUID   `json:"id"`
	Title            string      `json:"title"`
	Category         string      `json:"category"`
	Description      string      `json:"description"`
	GradeIds         []uuid.UUID `json:"grade_ids"`
	GradeNumber      []GradeEnum `json:"grade_number"`
	GradeDescription []string    `json:"grade_description"`
}

func (q *Queries) UpsertToxicityWithGrades(ctx context.Context, arg UpsertToxicityWithGradesParams) error {
	_, err := q.db.ExecContext(ctx, upsertToxicityWithGrades,
		arg.ID,
		arg.Title,
		arg.Category,
		arg.Description,
		pq.Array(arg.GradeIds),
		pq.Array(arg.GradeNumber),
		pq.Array(arg.GradeDescription),
	)
	return err
}
