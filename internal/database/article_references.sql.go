// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: article_references.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addArticleReferenceToProtocol = `-- name: AddArticleReferenceToProtocol :exec
INSERT INTO protocol_references_value (protocol_id, reference_id)
VALUES ($1, $2)
`

type AddArticleReferenceToProtocolParams struct {
	ProtocolID  uuid.UUID `json:"protocol_id"`
	ReferenceID uuid.UUID `json:"reference_id"`
}

func (q *Queries) AddArticleReferenceToProtocol(ctx context.Context, arg AddArticleReferenceToProtocolParams) error {
	_, err := q.db.ExecContext(ctx, addArticleReferenceToProtocol, arg.ProtocolID, arg.ReferenceID)
	return err
}

const createArticleReference = `-- name: CreateArticleReference :one
INSERT INTO article_references (title, authors, journal, year, doi, pmid)
VALUES ($1, $2, $3, $4, $5, $6)    
RETURNING id, created_at, updated_at, title, authors, journal, year, pmid, doi
`

type CreateArticleReferenceParams struct {
	Title   string `json:"title"`
	Authors string `json:"authors"`
	Journal string `json:"journal"`
	Year    string `json:"year"`
	Doi     string `json:"doi"`
	Pmid    string `json:"pmid"`
}

func (q *Queries) CreateArticleReference(ctx context.Context, arg CreateArticleReferenceParams) (ArticleReference, error) {
	row := q.db.QueryRowContext(ctx, createArticleReference,
		arg.Title,
		arg.Authors,
		arg.Journal,
		arg.Year,
		arg.Doi,
		arg.Pmid,
	)
	var i ArticleReference
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
	)
	return i, err
}

const deleteArticleReference = `-- name: DeleteArticleReference :exec
DELETE FROM article_references
WHERE id = $1
`

func (q *Queries) DeleteArticleReference(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteArticleReference, id)
	return err
}

const getALLArticles = `-- name: GetALLArticles :many
SELECT id, created_at, updated_at, title, authors, journal, year, pmid, doi FROM article_references
ORDER BY year DESC
`

func (q *Queries) GetALLArticles(ctx context.Context) ([]ArticleReference, error) {
	rows, err := q.db.QueryContext(ctx, getALLArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArticleReference{}
	for rows.Next() {
		var i ArticleReference
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Authors,
			&i.Journal,
			&i.Year,
			&i.Pmid,
			&i.Doi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleReferenceByData = `-- name: GetArticleReferenceByData :one
SELECT id, created_at, updated_at, title, authors, journal, year, pmid, doi FROM article_references
WHERE title = $1 AND authors = $2 AND journal = $3 AND year = $4
`

type GetArticleReferenceByDataParams struct {
	Title   string `json:"title"`
	Authors string `json:"authors"`
	Journal string `json:"journal"`
	Year    string `json:"year"`
}

func (q *Queries) GetArticleReferenceByData(ctx context.Context, arg GetArticleReferenceByDataParams) (ArticleReference, error) {
	row := q.db.QueryRowContext(ctx, getArticleReferenceByData,
		arg.Title,
		arg.Authors,
		arg.Journal,
		arg.Year,
	)
	var i ArticleReference
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
	)
	return i, err
}

const getArticleReferenceByID = `-- name: GetArticleReferenceByID :one
SELECT id, created_at, updated_at, title, authors, journal, year, pmid, doi FROM article_references
WHERE id = $1
`

func (q *Queries) GetArticleReferenceByID(ctx context.Context, id uuid.UUID) (ArticleReference, error) {
	row := q.db.QueryRowContext(ctx, getArticleReferenceByID, id)
	var i ArticleReference
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
	)
	return i, err
}

const getArticleReferenceByIDWithProtocols = `-- name: GetArticleReferenceByIDWithProtocols :one
SELECT ar.id, ar.created_at, ar.updated_at, ar.title, ar.authors, ar.journal, ar.year, ar.pmid, ar.doi, ARRAY_AGG(ROW(arpv.protocol_id,p.code)) AS protocol_ids
FROM article_references ar
JOIN protocol_references_value arpv ON ar.id = arpv.reference_id
JOIN protocols p ON arpv.protocol_id = p.id
WHERE ar.id = $1
GROUP BY ar.id
`

type GetArticleReferenceByIDWithProtocolsRow struct {
	ID          uuid.UUID   `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Title       string      `json:"title"`
	Authors     string      `json:"authors"`
	Journal     string      `json:"journal"`
	Year        string      `json:"year"`
	Pmid        string      `json:"pmid"`
	Doi         string      `json:"doi"`
	ProtocolIds interface{} `json:"protocol_ids"`
}

func (q *Queries) GetArticleReferenceByIDWithProtocols(ctx context.Context, id uuid.UUID) (GetArticleReferenceByIDWithProtocolsRow, error) {
	row := q.db.QueryRowContext(ctx, getArticleReferenceByIDWithProtocols, id)
	var i GetArticleReferenceByIDWithProtocolsRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
		&i.ProtocolIds,
	)
	return i, err
}

const getArticleReferences = `-- name: GetArticleReferences :many
SELECT 
    art.id, art.created_at, art.updated_at, art.title, art.authors, art.journal, art.year, art.pmid, art.doi, 
    COALESCE(
        (
            SELECT json_agg(
            json_build_object(
                'id', pecv.protocol_id, 
                'code', p.code
            )
        )
        FROM protocol_references_value pecv
        JOIN protocols p ON pecv.protocol_id = p.id
        WHERE pecv.reference_id = art.id
        ),
        '[]'
    ) AS protocol_ids
FROM 
    article_references art
`

type GetArticleReferencesRow struct {
	ID          uuid.UUID   `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Title       string      `json:"title"`
	Authors     string      `json:"authors"`
	Journal     string      `json:"journal"`
	Year        string      `json:"year"`
	Pmid        string      `json:"pmid"`
	Doi         string      `json:"doi"`
	ProtocolIds interface{} `json:"protocol_ids"`
}

func (q *Queries) GetArticleReferences(ctx context.Context) ([]GetArticleReferencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticleReferences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArticleReferencesRow{}
	for rows.Next() {
		var i GetArticleReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Authors,
			&i.Journal,
			&i.Year,
			&i.Pmid,
			&i.Doi,
			&i.ProtocolIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleReferencesByProtocol = `-- name: GetArticleReferencesByProtocol :many
SELECT article_references.id, article_references.created_at, article_references.updated_at, article_references.title, article_references.authors, article_references.journal, article_references.year, article_references.pmid, article_references.doi
FROM article_references
JOIN protocol_references_value ON article_references.id = protocol_references_value.reference_id
WHERE protocol_references_value.protocol_id = $1
ORDER BY article_references.year DESC
`

func (q *Queries) GetArticleReferencesByProtocol(ctx context.Context, protocolID uuid.UUID) ([]ArticleReference, error) {
	rows, err := q.db.QueryContext(ctx, getArticleReferencesByProtocol, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ArticleReference{}
	for rows.Next() {
		var i ArticleReference
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Authors,
			&i.Journal,
			&i.Year,
			&i.Pmid,
			&i.Doi,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleReferencesWithProtocols = `-- name: GetArticleReferencesWithProtocols :many
SELECT ar.id, ar.created_at, ar.updated_at, ar.title, ar.authors, ar.journal, ar.year, ar.pmid, ar.doi, ARRAY_AGG(ROW(arpv.protocol_id,p.code)) AS protocol_ids
FROM article_references ar
JOIN protocol_references_value arpv ON ar.id = arpv.reference_id
JOIN protocols p ON arpv.protocol_id = p.id
GROUP BY ar.id
`

type GetArticleReferencesWithProtocolsRow struct {
	ID          uuid.UUID   `json:"id"`
	CreatedAt   time.Time   `json:"created_at"`
	UpdatedAt   time.Time   `json:"updated_at"`
	Title       string      `json:"title"`
	Authors     string      `json:"authors"`
	Journal     string      `json:"journal"`
	Year        string      `json:"year"`
	Pmid        string      `json:"pmid"`
	Doi         string      `json:"doi"`
	ProtocolIds interface{} `json:"protocol_ids"`
}

func (q *Queries) GetArticleReferencesWithProtocols(ctx context.Context) ([]GetArticleReferencesWithProtocolsRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticleReferencesWithProtocols)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetArticleReferencesWithProtocolsRow{}
	for rows.Next() {
		var i GetArticleReferencesWithProtocolsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Authors,
			&i.Journal,
			&i.Year,
			&i.Pmid,
			&i.Doi,
			&i.ProtocolIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeArticleReferenceFromProtocol = `-- name: RemoveArticleReferenceFromProtocol :exec
DELETE FROM protocol_references_value
WHERE protocol_id = $1 AND reference_id = $2
`

type RemoveArticleReferenceFromProtocolParams struct {
	ProtocolID  uuid.UUID `json:"protocol_id"`
	ReferenceID uuid.UUID `json:"reference_id"`
}

func (q *Queries) RemoveArticleReferenceFromProtocol(ctx context.Context, arg RemoveArticleReferenceFromProtocolParams) error {
	_, err := q.db.ExecContext(ctx, removeArticleReferenceFromProtocol, arg.ProtocolID, arg.ReferenceID)
	return err
}

const updateArticleReference = `-- name: UpdateArticleReference :one
UPDATE article_references
SET
    updated_at = NOW(),
    title = $2,
    authors = $3,
    journal = $4,
    year = $5,
    doi = $6,
    pmid = $7    
WHERE id = $1
RETURNING id, created_at, updated_at, title, authors, journal, year, pmid, doi
`

type UpdateArticleReferenceParams struct {
	ID      uuid.UUID `json:"id"`
	Title   string    `json:"title"`
	Authors string    `json:"authors"`
	Journal string    `json:"journal"`
	Year    string    `json:"year"`
	Doi     string    `json:"doi"`
	Pmid    string    `json:"pmid"`
}

func (q *Queries) UpdateArticleReference(ctx context.Context, arg UpdateArticleReferenceParams) (ArticleReference, error) {
	row := q.db.QueryRowContext(ctx, updateArticleReference,
		arg.ID,
		arg.Title,
		arg.Authors,
		arg.Journal,
		arg.Year,
		arg.Doi,
		arg.Pmid,
	)
	var i ArticleReference
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
	)
	return i, err
}

const upsertArticleReference = `-- name: UpsertArticleReference :one
WITH input_values(id, title, authors, journal, year, doi, pmid) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1 
    END,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
  )
)
INSERT INTO article_references (id, title, authors, journal, year, doi, pmid)
SELECT id, title, authors, journal, year, doi, pmid FROM input_values
ON CONFLICT (id) DO UPDATE
SET title = EXCLUDED.title,
    authors = EXCLUDED.authors,
    journal = EXCLUDED.journal,
    year = EXCLUDED.year,
    doi = EXCLUDED.doi,
    pmid = EXCLUDED.pmid,
    updated_at = NOW()
RETURNING id, created_at, updated_at, title, authors, journal, year, pmid, doi
`

type UpsertArticleReferenceParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Column4 interface{} `json:"column_4"`
	Column5 interface{} `json:"column_5"`
	Column6 interface{} `json:"column_6"`
	Column7 interface{} `json:"column_7"`
}

func (q *Queries) UpsertArticleReference(ctx context.Context, arg UpsertArticleReferenceParams) (ArticleReference, error) {
	row := q.db.QueryRowContext(ctx, upsertArticleReference,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var i ArticleReference
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.Authors,
		&i.Journal,
		&i.Year,
		&i.Pmid,
		&i.Doi,
	)
	return i, err
}
