// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cancers.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const deleteCancer = `-- name: DeleteCancer :exec
DELETE FROM cancers
WHERE id = $1
`

func (q *Queries) DeleteCancer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteCancer, id)
	return err
}

const getCancerByID = `-- name: GetCancerByID :one
SELECT id, created_at, updated_at, code, name, tags, notes FROM cancers
WHERE id = $1
`

func (q *Queries) GetCancerByID(ctx context.Context, id uuid.UUID) (Cancer, error) {
	row := q.db.QueryRowContext(ctx, getCancerByID, id)
	var i Cancer
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Code,
		&i.Name,
		pq.Array(&i.Tags),
		&i.Notes,
	)
	return i, err
}

const getCancers = `-- name: GetCancers :many
SELECT id, created_at, updated_at, code, name, tags, notes FROM cancers
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type GetCancersParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCancers(ctx context.Context, arg GetCancersParams) ([]Cancer, error) {
	rows, err := q.db.QueryContext(ctx, getCancers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cancer
	for rows.Next() {
		var i Cancer
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Code,
			&i.Name,
			pq.Array(&i.Tags),
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCancersByTags = `-- name: GetCancersByTags :many
SELECT id, created_at, updated_at, code, name, tags, notes FROM cancers
WHERE tags @> $1
ORDER BY name ASC
LIMIT $1 OFFSET $2
`

type GetCancersByTagsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCancersByTags(ctx context.Context, arg GetCancersByTagsParams) ([]Cancer, error) {
	rows, err := q.db.QueryContext(ctx, getCancersByTags, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cancer
	for rows.Next() {
		var i Cancer
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Code,
			&i.Name,
			pq.Array(&i.Tags),
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCancersByTagsDesc = `-- name: GetCancersByTagsDesc :many
SELECT id, created_at, updated_at, code, name, tags, notes FROM cancers
WHERE tags @> $1
ORDER BY name DESC
LIMIT $1 OFFSET $2
`

type GetCancersByTagsDescParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetCancersByTagsDesc(ctx context.Context, arg GetCancersByTagsDescParams) ([]Cancer, error) {
	rows, err := q.db.QueryContext(ctx, getCancersByTagsDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cancer
	for rows.Next() {
		var i Cancer
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Code,
			&i.Name,
			pq.Array(&i.Tags),
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCancer = `-- name: UpdateCancer :one
UPDATE cancers
SET
    updated_at = NOW(),
    code = $2,
    name = $3,
    tags = $4,
    notes = $5
WHERE id = $1
RETURNING id, created_at, updated_at, code, name, tags, notes
`

type UpdateCancerParams struct {
	ID    uuid.UUID
	Code  sql.NullString
	Name  sql.NullString
	Tags  []string
	Notes string
}

func (q *Queries) UpdateCancer(ctx context.Context, arg UpdateCancerParams) (Cancer, error) {
	row := q.db.QueryRowContext(ctx, updateCancer,
		arg.ID,
		arg.Code,
		arg.Name,
		pq.Array(arg.Tags),
		arg.Notes,
	)
	var i Cancer
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Code,
		&i.Name,
		pq.Array(&i.Tags),
		&i.Notes,
	)
	return i, err
}
