// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: lab_tests.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const addTest = `-- name: AddTest :one
INSERT INTO tests (name, description, form_url, unit, lower_limit, upper_limit, test_category)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type AddTestParams struct {
	Name         string  `json:"name"`
	Description  string  `json:"description"`
	FormUrl      string  `json:"form_url"`
	Unit         string  `json:"unit"`
	LowerLimit   float64 `json:"lower_limit"`
	UpperLimit   float64 `json:"upper_limit"`
	TestCategory string  `json:"test_category"`
}

func (q *Queries) AddTest(ctx context.Context, arg AddTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, addTest,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const addTestToProtocolByCategoryAndUrgency = `-- name: AddTestToProtocolByCategoryAndUrgency :one
INSERT INTO protocol_tests (protocol_id, test_id, category, urgency)
VALUES ($1, $2, $3, $4)
RETURNING protocol_id, test_id, category, urgency
`

type AddTestToProtocolByCategoryAndUrgencyParams struct {
	ProtocolID uuid.UUID    `json:"protocol_id"`
	TestID     uuid.UUID    `json:"test_id"`
	Category   CategoryEnum `json:"category"`
	Urgency    UrgencyEnum  `json:"urgency"`
}

func (q *Queries) AddTestToProtocolByCategoryAndUrgency(ctx context.Context, arg AddTestToProtocolByCategoryAndUrgencyParams) (ProtocolTest, error) {
	row := q.db.QueryRowContext(ctx, addTestToProtocolByCategoryAndUrgency,
		arg.ProtocolID,
		arg.TestID,
		arg.Category,
		arg.Urgency,
	)
	var i ProtocolTest
	err := row.Scan(
		&i.ProtocolID,
		&i.TestID,
		&i.Category,
		&i.Urgency,
	)
	return i, err
}

const deleteTest = `-- name: DeleteTest :exec
DELETE FROM tests WHERE id = $1
`

func (q *Queries) DeleteTest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTest, id)
	return err
}

const getTestByID = `-- name: GetTestByID :one
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE id = $1
`

func (q *Queries) GetTestByID(ctx context.Context, id uuid.UUID) (Test, error) {
	row := q.db.QueryRowContext(ctx, getTestByID, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const getTestByName = `-- name: GetTestByName :one
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE name = $1
`

func (q *Queries) GetTestByName(ctx context.Context, name string) (Test, error) {
	row := q.db.QueryRowContext(ctx, getTestByName, name)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const getTests = `-- name: GetTests :many
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests
`

func (q *Queries) GetTests(ctx context.Context) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, getTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.FormUrl,
			&i.Unit,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.TestCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestsByCategory = `-- name: GetTestsByCategory :many
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE test_category = $1
`

func (q *Queries) GetTestsByCategory(ctx context.Context, testCategory string) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, getTestsByCategory, testCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.FormUrl,
			&i.Unit,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.TestCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestsByProtocol = `-- name: GetTestsByProtocol :one
SELECT jsonb_build_object(
  'tests', jsonb_build_object(
    'baseline', jsonb_build_object(
      'urgent', COALESCE((
        SELECT jsonb_agg(to_jsonb(t) -> 'test') FROM (
          SELECT 
            json_build_object(
              'id', tst.id,
              'name', tst.name,
              'description', tst.description
            ) AS test
          FROM tests tst
          JOIN protocol_tests pt ON pt.test_id = tst.id
          WHERE pt.protocol_id = $1 AND pt.category = 'baseline' AND pt.urgency = 'urgent'
        ) sub
      ), '[]'::jsonb),
      
      'non_urgent', COALESCE((
        SELECT jsonb_agg(to_jsonb(t) -> 'test') FROM (
          SELECT json_build_object('id', tst.id, 'name', tst.name, 'description', tst.description) AS test
          FROM tests tst
          JOIN protocol_tests pt ON pt.test_id = tst.id
          WHERE pt.protocol_id = $1 AND pt.category = 'baseline' AND pt.urgency = 'non_urgent'
        ) t
      ), '[]'::jsonb),

      'if_necessary', COALESCE((
        SELECT jsonb_agg(to_jsonb(t) -> 'test') FROM (
          SELECT json_build_object('id', tst.id, 'name', tst.name, 'description', tst.description) AS test
          FROM tests tst
          JOIN protocol_tests pt ON pt.test_id = tst.id
          WHERE pt.protocol_id = $1 AND pt.category = 'baseline' AND pt.urgency = 'if_necessary'
        ) t
      ), '[]'::jsonb)
    ),

    'followup', jsonb_build_object(
      'urgent', COALESCE((
        SELECT jsonb_agg(to_jsonb(t) -> 'test') FROM (
          SELECT json_build_object('id', tst.id, 'name', tst.name, 'description', tst.description) AS test
          FROM tests tst
          JOIN protocol_tests pt ON pt.test_id = tst.id
          WHERE pt.protocol_id = $1 AND pt.category = 'followup' AND pt.urgency = 'urgent'
        ) t
      ), '[]'::jsonb),

      'if_necessary', COALESCE((
        SELECT jsonb_agg(to_jsonb(t) -> 'test') FROM (
          SELECT json_build_object('id', tst.id, 'name', tst.name, 'description', tst.description) AS test
          FROM tests tst
          JOIN protocol_tests pt ON pt.test_id = tst.id
          WHERE pt.protocol_id = $1 AND pt.category = 'followup' AND pt.urgency = 'if_necessary'
        ) t
      ), '[]'::jsonb)
    )
  )
) AS tests
`

func (q *Queries) GetTestsByProtocol(ctx context.Context, protocolID uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getTestsByProtocol, protocolID)
	var tests json.RawMessage
	err := row.Scan(&tests)
	return tests, err
}

const getTestsByProtocolByCategoryAndUrgency = `-- name: GetTestsByProtocolByCategoryAndUrgency :many
SELECT t.id, t.created_at, t.updated_at, t.name, t.description, t.form_url, t.unit, t.lower_limit, t.upper_limit, t.test_category
FROM tests t
JOIN protocol_tests pt ON t.id = pt.test_id
WHERE pt.protocol_id = $1 AND pt.category = $2 AND pt.urgency = $3
`

type GetTestsByProtocolByCategoryAndUrgencyParams struct {
	ProtocolID uuid.UUID    `json:"protocol_id"`
	Category   CategoryEnum `json:"category"`
	Urgency    UrgencyEnum  `json:"urgency"`
}

func (q *Queries) GetTestsByProtocolByCategoryAndUrgency(ctx context.Context, arg GetTestsByProtocolByCategoryAndUrgencyParams) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, getTestsByProtocolByCategoryAndUrgency, arg.ProtocolID, arg.Category, arg.Urgency)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.FormUrl,
			&i.Unit,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.TestCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTestFromProtocolByCategoryAndUrgency = `-- name: RemoveTestFromProtocolByCategoryAndUrgency :exec
DELETE FROM protocol_tests WHERE protocol_id = $1 AND test_id = $2 AND category = $3 AND urgency = $4
`

type RemoveTestFromProtocolByCategoryAndUrgencyParams struct {
	ProtocolID uuid.UUID    `json:"protocol_id"`
	TestID     uuid.UUID    `json:"test_id"`
	Category   CategoryEnum `json:"category"`
	Urgency    UrgencyEnum  `json:"urgency"`
}

func (q *Queries) RemoveTestFromProtocolByCategoryAndUrgency(ctx context.Context, arg RemoveTestFromProtocolByCategoryAndUrgencyParams) error {
	_, err := q.db.ExecContext(ctx, removeTestFromProtocolByCategoryAndUrgency,
		arg.ProtocolID,
		arg.TestID,
		arg.Category,
		arg.Urgency,
	)
	return err
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests
SET name = $2, description = $3, form_url = $4, unit = $5, lower_limit = $6, upper_limit = $7, test_category = $8
WHERE id = $1
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type UpdateTestParams struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Description  string    `json:"description"`
	FormUrl      string    `json:"form_url"`
	Unit         string    `json:"unit"`
	LowerLimit   float64   `json:"lower_limit"`
	UpperLimit   float64   `json:"upper_limit"`
	TestCategory string    `json:"test_category"`
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, updateTest,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const upsertTest = `-- name: UpsertTest :one
WITH input_values(id, name, description, form_url, unit, lower_limit, upper_limit, test_category) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1 
    END,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8::test_category_enum
  )
)
INSERT INTO tests (id, name, description, form_url, unit, lower_limit, upper_limit, test_category)
SELECT id, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM input_values
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    description = EXCLUDED.description,
    form_url = EXCLUDED.form_url,
    unit = EXCLUDED.unit,
    lower_limit = EXCLUDED.lower_limit,
    upper_limit = EXCLUDED.upper_limit,
    test_category = EXCLUDED.test_category,
    updated_at = NOW()
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type UpsertTestParams struct {
	ID           interface{} `json:"id"`
	Name         interface{} `json:"name"`
	Description  interface{} `json:"description"`
	FormUrl      interface{} `json:"form_url"`
	Unit         interface{} `json:"unit"`
	LowerLimit   interface{} `json:"lower_limit"`
	UpperLimit   interface{} `json:"upper_limit"`
	TestCategory interface{} `json:"test_category"`
}

func (q *Queries) UpsertTest(ctx context.Context, arg UpsertTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, upsertTest,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}
