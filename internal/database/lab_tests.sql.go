// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: lab_tests.sql

package database

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const addTest = `-- name: AddTest :one
INSERT INTO tests (name, description, form_url, unit, lower_limit, upper_limit, test_category)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type AddTestParams struct {
	Name         string  `json:"name"`
	Description  string  `json:"description"`
	FormUrl      string  `json:"form_url"`
	Unit         string  `json:"unit"`
	LowerLimit   float64 `json:"lower_limit"`
	UpperLimit   float64 `json:"upper_limit"`
	TestCategory string  `json:"test_category"`
}

func (q *Queries) AddTest(ctx context.Context, arg AddTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, addTest,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const addTestToProtoTestCategory = `-- name: AddTestToProtoTestCategory :exec
INSERT INTO protocol_tests_value (protocol_tests_id, tests_id)
VALUES ($1, $2)
`

type AddTestToProtoTestCategoryParams struct {
	ProtocolTestsID uuid.UUID `json:"protocol_tests_id"`
	TestsID         uuid.UUID `json:"tests_id"`
}

func (q *Queries) AddTestToProtoTestCategory(ctx context.Context, arg AddTestToProtoTestCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addTestToProtoTestCategory, arg.ProtocolTestsID, arg.TestsID)
	return err
}

const deleteTest = `-- name: DeleteTest :exec
DELETE FROM tests WHERE id = $1
`

func (q *Queries) DeleteTest(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTest, id)
	return err
}

const getProtocolTests = `-- name: GetProtocolTests :one
SELECT COALESCE(jsonb_agg(protocol_tests_data ORDER BY protocol_tests_data.position), '[]'::jsonb) AS data
FROM (
  SELECT 
    pt.id,
    pt.created_at,
    pt.updated_at,
    pt.category,
    pt.comments,
    pt.position,
    COALESCE(tests.tests, '[]'::jsonb) AS tests
  FROM protocol_tests pt
  LEFT JOIN LATERAL (
    SELECT jsonb_agg(
      jsonb_build_object(
        'id', t.id,
        'name', t.name,
        'created_at', t.created_at,
        'updated_at', t.updated_at,
        'description', t.description,
        'form_url', t.form_url,
        'unit', t.unit,
        'lower_limit', t.lower_limit,
        'upper_limit', t.upper_limit,
        'test_category', t.test_category
      ) ORDER BY t.test_category, t.name
    ) AS tests
    FROM tests t
    JOIN protocol_tests_value ptv
      ON ptv.tests_id = t.id
    WHERE ptv.protocol_tests_id = pt.id
  ) tests ON TRUE
  WHERE pt.protocol_id = $1
) protocol_tests_data
`

func (q *Queries) GetProtocolTests(ctx context.Context, protocolID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProtocolTests, protocolID)
	var data interface{}
	err := row.Scan(&data)
	return data, err
}

const getTestByID = `-- name: GetTestByID :one
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE id = $1
`

func (q *Queries) GetTestByID(ctx context.Context, id uuid.UUID) (Test, error) {
	row := q.db.QueryRowContext(ctx, getTestByID, id)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const getTestByName = `-- name: GetTestByName :one
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE name = $1
`

func (q *Queries) GetTestByName(ctx context.Context, name string) (Test, error) {
	row := q.db.QueryRowContext(ctx, getTestByName, name)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const getTestCategoryByID = `-- name: GetTestCategoryByID :one
SELECT jsonb_build_object(
  'id', pt.id,
  'created_at', pt.created_at,
  'updated_at', pt.updated_at,
  'category', pt.category,
  'comments', pt.comments,
  'position', pt.position,
  'tests', COALESCE((
    SELECT jsonb_agg(jsonb_build_object(
      'id', t.id,
      'name', t.name,
      'created_at', t.created_at,
      'updated_at', t.updated_at,
      'description', t.description,
      'form_url', t.form_url,
      'unit', t.unit,
      'lower_limit', t.lower_limit,
      'upper_limit', t.upper_limit,
      'test_category', t.test_category
    ) ORDER BY t.test_category, t.name)
    FROM tests t
    JOIN protocol_tests_value tc ON tc.tests_id = t.id AND tc.protocol_tests_id = pt.id
  ), '[]'::jsonb)
) AS data
FROM protocol_tests pt
WHERE pt.id = $1
`

func (q *Queries) GetTestCategoryByID(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getTestCategoryByID, id)
	var data json.RawMessage
	err := row.Scan(&data)
	return data, err
}

const getTests = `-- name: GetTests :many
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests
`

func (q *Queries) GetTests(ctx context.Context) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, getTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.FormUrl,
			&i.Unit,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.TestCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestsByCategory = `-- name: GetTestsByCategory :many
SELECT id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM tests WHERE test_category = $1
`

func (q *Queries) GetTestsByCategory(ctx context.Context, testCategory string) ([]Test, error) {
	rows, err := q.db.QueryContext(ctx, getTestsByCategory, testCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Test{}
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.FormUrl,
			&i.Unit,
			&i.LowerLimit,
			&i.UpperLimit,
			&i.TestCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTestCategoryByID = `-- name: RemoveTestCategoryByID :exec
DELETE FROM protocol_tests
WHERE id = $1
`

func (q *Queries) RemoveTestCategoryByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeTestCategoryByID, id)
	return err
}

const removeTestToProtoTestCategory = `-- name: RemoveTestToProtoTestCategory :exec
DELETE FROM protocol_tests_value
WHERE protocol_tests_id = $1 AND tests_id = $2
`

type RemoveTestToProtoTestCategoryParams struct {
	ProtocolTestsID uuid.UUID `json:"protocol_tests_id"`
	TestsID         uuid.UUID `json:"tests_id"`
}

func (q *Queries) RemoveTestToProtoTestCategory(ctx context.Context, arg RemoveTestToProtoTestCategoryParams) error {
	_, err := q.db.ExecContext(ctx, removeTestToProtoTestCategory, arg.ProtocolTestsID, arg.TestsID)
	return err
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests
SET name = $2, description = $3, form_url = $4, unit = $5, lower_limit = $6, upper_limit = $7, test_category = $8
WHERE id = $1
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type UpdateTestParams struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Description  string    `json:"description"`
	FormUrl      string    `json:"form_url"`
	Unit         string    `json:"unit"`
	LowerLimit   float64   `json:"lower_limit"`
	UpperLimit   float64   `json:"upper_limit"`
	TestCategory string    `json:"test_category"`
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, updateTest,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}

const upsertProtoTestCategory = `-- name: UpsertProtoTestCategory :one
WITH input_values(id, protocol_id, category, comments,position) AS (
  VALUES (
    CASE 
      WHEN $1::uuid  = '00000000-0000-0000-0000-000000000000'
      THEN gen_random_uuid() 
      ELSE $1::uuid 
    END,
    $2::uuid,
    $3::TEXT,
    $4::text,
    COALESCE($5::INT, 0)
  )
)
INSERT INTO protocol_tests (id, protocol_id, category, comments,position)
SELECT id, protocol_id, category, comments,position FROM input_values
ON CONFLICT (id) DO UPDATE
SET protocol_id = EXCLUDED.protocol_id,
    category = EXCLUDED.category,
    comments = EXCLUDED.comments,
    position = EXCLUDED.position,   
    updated_at = NOW()
RETURNING id, created_at, updated_at, protocol_id, category, comments, position
`

type UpsertProtoTestCategoryParams struct {
	ID         uuid.UUID `json:"id"`
	ProtocolID uuid.UUID `json:"protocol_id"`
	Category   string    `json:"category"`
	Comments   string    `json:"comments"`
	Position   int32     `json:"position"`
}

func (q *Queries) UpsertProtoTestCategory(ctx context.Context, arg UpsertProtoTestCategoryParams) (ProtocolTest, error) {
	row := q.db.QueryRowContext(ctx, upsertProtoTestCategory,
		arg.ID,
		arg.ProtocolID,
		arg.Category,
		arg.Comments,
		arg.Position,
	)
	var i ProtocolTest
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProtocolID,
		&i.Category,
		&i.Comments,
		&i.Position,
	)
	return i, err
}

const upsertTest = `-- name: UpsertTest :one
WITH input_values(id, name, description, form_url, unit, lower_limit, upper_limit, test_category) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1 
    END,
    $2,
    $3,
    $4,
    $5,
    $6::FLOAT,
    $7::FLOAT,
    $8
  )
)
INSERT INTO tests (id, name, description, form_url, unit, lower_limit, upper_limit, test_category)
SELECT id, name, description, form_url, unit, lower_limit, upper_limit, test_category FROM input_values
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    description = EXCLUDED.description,
    form_url = EXCLUDED.form_url,
    unit = EXCLUDED.unit,
    lower_limit = EXCLUDED.lower_limit,
    upper_limit = EXCLUDED.upper_limit,
    test_category = EXCLUDED.test_category,
    updated_at = NOW()
RETURNING id, created_at, updated_at, name, description, form_url, unit, lower_limit, upper_limit, test_category
`

type UpsertTestParams struct {
	ID           interface{} `json:"id"`
	Name         interface{} `json:"name"`
	Description  interface{} `json:"description"`
	FormUrl      interface{} `json:"form_url"`
	Unit         interface{} `json:"unit"`
	LowerLimit   float64     `json:"lower_limit"`
	UpperLimit   float64     `json:"upper_limit"`
	TestCategory interface{} `json:"test_category"`
}

func (q *Queries) UpsertTest(ctx context.Context, arg UpsertTestParams) (Test, error) {
	row := q.db.QueryRowContext(ctx, upsertTest,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.FormUrl,
		arg.Unit,
		arg.LowerLimit,
		arg.UpperLimit,
		arg.TestCategory,
	)
	var i Test
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.FormUrl,
		&i.Unit,
		&i.LowerLimit,
		&i.UpperLimit,
		&i.TestCategory,
	)
	return i, err
}
