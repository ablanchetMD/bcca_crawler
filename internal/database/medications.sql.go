// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: medications.sql

package database

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addMedication = `-- name: AddMedication :one
INSERT INTO medications (name, description, category,alternate_names)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, name, description, alternate_names, category
`

type AddMedicationParams struct {
	Name           string   `json:"name"`
	Description    string   `json:"description"`
	Category       string   `json:"category"`
	AlternateNames []string `json:"alternate_names"`
}

func (q *Queries) AddMedication(ctx context.Context, arg AddMedicationParams) (Medication, error) {
	row := q.db.QueryRowContext(ctx, addMedication,
		arg.Name,
		arg.Description,
		arg.Category,
		pq.Array(arg.AlternateNames),
	)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const addMedicationModification = `-- name: AddMedicationModification :one
INSERT INTO medication_modifications (category, subcategory, adjustment, medication_id)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type AddMedicationModificationParams struct {
	Category     MedAdjCategoryEnum `json:"category"`
	Subcategory  string             `json:"subcategory"`
	Adjustment   string             `json:"adjustment"`
	MedicationID uuid.UUID          `json:"medication_id"`
}

func (q *Queries) AddMedicationModification(ctx context.Context, arg AddMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, addMedicationModification,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const addPrescription = `-- name: AddPrescription :one
INSERT INTO medication_prescription (medication_id, dose, route, frequency, duration, instructions, renewals)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, medication_id, dose, route, frequency, duration, instructions, renewals
`

type AddPrescriptionParams struct {
	MedicationID uuid.UUID             `json:"medication_id"`
	Dose         string                `json:"dose"`
	Route        PrescriptionRouteEnum `json:"route"`
	Frequency    string                `json:"frequency"`
	Duration     string                `json:"duration"`
	Instructions string                `json:"instructions"`
	Renewals     int32                 `json:"renewals"`
}

func (q *Queries) AddPrescription(ctx context.Context, arg AddPrescriptionParams) (MedicationPrescription, error) {
	row := q.db.QueryRowContext(ctx, addPrescription,
		arg.MedicationID,
		arg.Dose,
		arg.Route,
		arg.Frequency,
		arg.Duration,
		arg.Instructions,
		arg.Renewals,
	)
	var i MedicationPrescription
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MedicationID,
		&i.Dose,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}

const addPrescriptionToProtocolCategory = `-- name: AddPrescriptionToProtocolCategory :exec
INSERT INTO protocol_meds_values (protocol_meds_id, medication_prescription_id)
VALUES ($1, $2)
`

type AddPrescriptionToProtocolCategoryParams struct {
	ProtocolMedsID           uuid.UUID `json:"protocol_meds_id"`
	MedicationPrescriptionID uuid.UUID `json:"medication_prescription_id"`
}

func (q *Queries) AddPrescriptionToProtocolCategory(ctx context.Context, arg AddPrescriptionToProtocolCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addPrescriptionToProtocolCategory, arg.ProtocolMedsID, arg.MedicationPrescriptionID)
	return err
}

const deleteMedication = `-- name: DeleteMedication :exec
DELETE FROM medications
WHERE id = $1
`

func (q *Queries) DeleteMedication(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteMedication, id)
	return err
}

const getMedCategoryByID = `-- name: GetMedCategoryByID :one
SELECT jsonb_build_object(
  'id', pm.id,
  'created_at', pm.created_at,
  'updated_at', pm.updated_at,
  'category', pm.category,
  'comments', pm.comments,
  'medications', COALESCE((
    SELECT jsonb_agg(
      jsonb_build_object(            
        'id', mp.id,
        'dose', mp.dose,
        'route', mp.route,
        'frequency', mp.frequency,
        'duration', mp.duration,
        'instructions', mp.instructions,
        'renewals', mp.renewals,
        'medication_id', m.id,
        'medication_name', m.name,
        'medication_description', m.description,
        'medication_category', m.category,
        'medication_alternates', m.alternate_names
      )
      ORDER BY m.name
    )
    FROM protocol_meds_values pmv
    JOIN medication_prescription mp ON mp.id = pmv.medication_prescription_id
    JOIN medications m ON m.id = mp.medication_id
    WHERE pmv.protocol_meds_id = pm.id
  ), '[]'::jsonb)
)
FROM protocol_meds pm
WHERE pm.id = $1
`

func (q *Queries) GetMedCategoryByID(ctx context.Context, id uuid.UUID) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, getMedCategoryByID, id)
	var jsonb_build_object json.RawMessage
	err := row.Scan(&jsonb_build_object)
	return jsonb_build_object, err
}

const getMedicationByID = `-- name: GetMedicationByID :one
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE id = $1
`

func (q *Queries) GetMedicationByID(ctx context.Context, id uuid.UUID) (Medication, error) {
	row := q.db.QueryRowContext(ctx, getMedicationByID, id)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const getMedicationByName = `-- name: GetMedicationByName :one
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE name = $1
`

func (q *Queries) GetMedicationByName(ctx context.Context, name string) (Medication, error) {
	row := q.db.QueryRowContext(ctx, getMedicationByName, name)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const getMedicationModificationByID = `-- name: GetMedicationModificationByID :one
SELECT id, created_at, updated_at, category, subcategory, adjustment, medication_id FROM medication_modifications
WHERE id = $1
`

func (q *Queries) GetMedicationModificationByID(ctx context.Context, id uuid.UUID) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, getMedicationModificationByID, id)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const getMedicationModificationsByMedication = `-- name: GetMedicationModificationsByMedication :many
SELECT m.id as medication_id, mod.id as modification_id, mod.category as modification_category, mod.subcategory as modification_subcategory, mod.adjustment
FROM medication_modifications mod
JOIN medications m ON mod.medication_id = m.id
WHERE m.id = $1
`

type GetMedicationModificationsByMedicationRow struct {
	MedicationID            uuid.UUID          `json:"medication_id"`
	ModificationID          uuid.UUID          `json:"modification_id"`
	ModificationCategory    MedAdjCategoryEnum `json:"modification_category"`
	ModificationSubcategory string             `json:"modification_subcategory"`
	Adjustment              string             `json:"adjustment"`
}

func (q *Queries) GetMedicationModificationsByMedication(ctx context.Context, id uuid.UUID) ([]GetMedicationModificationsByMedicationRow, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationModificationsByMedication, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMedicationModificationsByMedicationRow{}
	for rows.Next() {
		var i GetMedicationModificationsByMedicationRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.ModificationID,
			&i.ModificationCategory,
			&i.ModificationSubcategory,
			&i.Adjustment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationModificationsByProtocol = `-- name: GetMedicationModificationsByProtocol :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, mod.id as modification_id, mod.category as modification_category, mod.subcategory as modification_subcategory, mod.adjustment
FROM medication_modifications mod
JOIN medications m ON mod.medication_id = m.id
JOIN protocol_treatment pt ON m.id = pt.medication_id
JOIN treatment_cycles_values tc ON pt.id = tc.protocol_treatment_id
JOIN protocol_cycles pc ON tc.protocol_cycles_id = pc.id
WHERE pc.protocol_id = $1
`

type GetMedicationModificationsByProtocolRow struct {
	MedicationID            uuid.UUID          `json:"medication_id"`
	Name                    string             `json:"name"`
	Description             string             `json:"description"`
	Category                string             `json:"category"`
	AlternateNames          []string           `json:"alternate_names"`
	ModificationID          uuid.UUID          `json:"modification_id"`
	ModificationCategory    MedAdjCategoryEnum `json:"modification_category"`
	ModificationSubcategory string             `json:"modification_subcategory"`
	Adjustment              string             `json:"adjustment"`
}

func (q *Queries) GetMedicationModificationsByProtocol(ctx context.Context, protocolID uuid.UUID) ([]GetMedicationModificationsByProtocolRow, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationModificationsByProtocol, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMedicationModificationsByProtocolRow{}
	for rows.Next() {
		var i GetMedicationModificationsByProtocolRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.ModificationID,
			&i.ModificationCategory,
			&i.ModificationSubcategory,
			&i.Adjustment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedications = `-- name: GetMedications :many
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
ORDER BY name ASC
`

func (q *Queries) GetMedications(ctx context.Context) ([]Medication, error) {
	rows, err := q.db.QueryContext(ctx, getMedications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medication{}
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			pq.Array(&i.AlternateNames),
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationsByCategory = `-- name: GetMedicationsByCategory :many
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE category = $1
ORDER BY name ASC
`

func (q *Queries) GetMedicationsByCategory(ctx context.Context, category string) ([]Medication, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medication{}
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			pq.Array(&i.AlternateNames),
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModificationsByMedication = `-- name: GetModificationsByMedication :many
SELECT id, created_at, updated_at, category, subcategory, adjustment, medication_id FROM medication_modifications
WHERE medication_id = $1
`

func (q *Queries) GetModificationsByMedication(ctx context.Context, medicationID uuid.UUID) ([]MedicationModification, error) {
	rows, err := q.db.QueryContext(ctx, getModificationsByMedication, medicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MedicationModification{}
	for rows.Next() {
		var i MedicationModification
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.Subcategory,
			&i.Adjustment,
			&i.MedicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionByID = `-- name: GetPrescriptionByID :one
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose,p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication_id
WHERE p.id = $1
`

type GetPrescriptionByIDRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionByID(ctx context.Context, id uuid.UUID) (GetPrescriptionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPrescriptionByID, id)
	var i GetPrescriptionByIDRow
	err := row.Scan(
		&i.MedicationID,
		&i.Name,
		&i.Description,
		&i.Category,
		pq.Array(&i.AlternateNames),
		&i.MedicationPrescriptionID,
		&i.Dose,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}

const getPrescriptions = `-- name: GetPrescriptions :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication_id
ORDER BY m.name ASC
`

type GetPrescriptionsRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptions(ctx context.Context) ([]GetPrescriptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsRow{}
	for rows.Next() {
		var i GetPrescriptionsRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionsByArguments = `-- name: GetPrescriptionsByArguments :one
SELECT p.id 
FROM medication_prescription p
WHERE p.medication_id = $1 AND p.dose = $2 AND p.route = $3
  AND p.frequency = $4 AND p.duration = $5 AND p.instructions = $6
`

type GetPrescriptionsByArgumentsParams struct {
	MedicationID uuid.UUID             `json:"medication_id"`
	Dose         string                `json:"dose"`
	Route        PrescriptionRouteEnum `json:"route"`
	Frequency    string                `json:"frequency"`
	Duration     string                `json:"duration"`
	Instructions string                `json:"instructions"`
}

func (q *Queries) GetPrescriptionsByArguments(ctx context.Context, arg GetPrescriptionsByArgumentsParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getPrescriptionsByArguments,
		arg.MedicationID,
		arg.Dose,
		arg.Route,
		arg.Frequency,
		arg.Duration,
		arg.Instructions,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getPrescriptionsByMed = `-- name: GetPrescriptionsByMed :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication_id
WHERE m.id = $1
`

type GetPrescriptionsByMedRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionsByMed(ctx context.Context, id uuid.UUID) ([]GetPrescriptionsByMedRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptionsByMed, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsByMedRow{}
	for rows.Next() {
		var i GetPrescriptionsByMedRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionsByProtocolByCategory = `-- name: GetPrescriptionsByProtocolByCategory :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication_id
JOIN protocol_meds pm ON p.id = pm.prescription_id
WHERE pm.protocol_id = $1 AND pm.category = $2
`

type GetPrescriptionsByProtocolByCategoryParams struct {
	ProtocolID uuid.UUID `json:"protocol_id"`
	Category   string    `json:"category"`
}

type GetPrescriptionsByProtocolByCategoryRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionsByProtocolByCategory(ctx context.Context, arg GetPrescriptionsByProtocolByCategoryParams) ([]GetPrescriptionsByProtocolByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptionsByProtocolByCategory, arg.ProtocolID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsByProtocolByCategoryRow{}
	for rows.Next() {
		var i GetPrescriptionsByProtocolByCategoryRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProtocolMedicationsWithModifications = `-- name: GetProtocolMedicationsWithModifications :many
SELECT 
  m.id AS medication_id,
  m.name AS medication_name,
  jsonb_agg(
    jsonb_build_object(
      'category', grouped.category,
      'subcategories', grouped.subcategories
    )
  ) AS categories
FROM protocol_treatment pt
JOIN medications m ON m.id = pt.medication_id

JOIN LATERAL (
  SELECT 
    mm1.category,
    jsonb_agg(
      jsonb_build_object(
        'subcategory', mm1.subcategory,
        'adjustment', mm1.adjustment
      )
    ) AS subcategories
  FROM medication_modifications mm1
  WHERE mm1.medication_id = m.id
  GROUP BY mm1.category
) AS grouped ON true

WHERE pt.id IN (
  SELECT ptv.protocol_treatment_id
  FROM treatment_cycles_values ptv
  JOIN protocol_cycles pc ON pc.id = ptv.protocol_cycles_id
  WHERE pc.protocol_id = $1
)

GROUP BY m.id, m.name
`

type GetProtocolMedicationsWithModificationsRow struct {
	MedicationID   uuid.UUID       `json:"medication_id"`
	MedicationName string          `json:"medication_name"`
	Categories     json.RawMessage `json:"categories"`
}

func (q *Queries) GetProtocolMedicationsWithModifications(ctx context.Context, protocolID uuid.UUID) ([]GetProtocolMedicationsWithModificationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProtocolMedicationsWithModifications, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProtocolMedicationsWithModificationsRow{}
	for rows.Next() {
		var i GetProtocolMedicationsWithModificationsRow
		if err := rows.Scan(&i.MedicationID, &i.MedicationName, &i.Categories); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProtocolPrescriptions = `-- name: GetProtocolPrescriptions :one
SELECT COALESCE(jsonb_agg(protocol_prescriptions ORDER BY category ASC), '[]'::jsonb) AS data
FROM (
  SELECT 
    pro.id,
    pro.created_at,
    pro.updated_at,
    pro.category,
    pro.comments,     
    COALESCE((
      SELECT jsonb_agg(prescription_data)
      FROM (
        SELECT 
          jsonb_build_object(            
            'id', mp.id,
            'dose', mp.dose,
            'route', mp.route,
            'frequency', mp.frequency,
            'duration', mp.duration,
            'instructions', mp.instructions,
            'renewals', mp.renewals,
            'medication_id', m.id,
            'medication_name', m.name,
            'medication_description', m.description,
            'medication_category',m.category,
            'medication_alternates',m.alternate_names
          ) AS prescription_data                 
        FROM protocol_meds_values pmv
        JOIN medication_prescription mp ON mp.id = pmv.medication_prescription_id
        JOIN medications m ON m.id = mp.medication_id
        WHERE pmv.protocol_meds_id = pro.id
        ORDER BY m.name
      ) t
    ), '[]'::jsonb) AS medications
  FROM protocol_meds pro  
  WHERE pro.protocol_id = $1
) AS protocol_prescriptions
`

func (q *Queries) GetProtocolPrescriptions(ctx context.Context, protocolID uuid.UUID) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProtocolPrescriptions, protocolID)
	var data interface{}
	err := row.Scan(&data)
	return data, err
}

const removeMedCategoryByID = `-- name: RemoveMedCategoryByID :exec
DELETE FROM protocol_meds
WHERE id = $1
`

func (q *Queries) RemoveMedCategoryByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeMedCategoryByID, id)
	return err
}

const removeMedicationModification = `-- name: RemoveMedicationModification :exec
DELETE FROM medication_modifications
WHERE id = $1
`

func (q *Queries) RemoveMedicationModification(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeMedicationModification, id)
	return err
}

const removePrescription = `-- name: RemovePrescription :exec
DELETE FROM medication_prescription
WHERE id = $1
`

func (q *Queries) RemovePrescription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removePrescription, id)
	return err
}

const removePrescriptionFromProtocolCategory = `-- name: RemovePrescriptionFromProtocolCategory :exec
DELETE FROM protocol_meds_values
WHERE protocol_meds_id = $1 AND medication_prescription_id = $2
`

type RemovePrescriptionFromProtocolCategoryParams struct {
	ProtocolMedsID           uuid.UUID `json:"protocol_meds_id"`
	MedicationPrescriptionID uuid.UUID `json:"medication_prescription_id"`
}

func (q *Queries) RemovePrescriptionFromProtocolCategory(ctx context.Context, arg RemovePrescriptionFromProtocolCategoryParams) error {
	_, err := q.db.ExecContext(ctx, removePrescriptionFromProtocolCategory, arg.ProtocolMedsID, arg.MedicationPrescriptionID)
	return err
}

const updateMedicationModification = `-- name: UpdateMedicationModification :one
UPDATE medication_modifications
SET
    updated_at = NOW(),
    category = $2,
    subcategory = $3,
    adjustment = $4,
    medication_id = $5
WHERE id = $1
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type UpdateMedicationModificationParams struct {
	ID           uuid.UUID          `json:"id"`
	Category     MedAdjCategoryEnum `json:"category"`
	Subcategory  string             `json:"subcategory"`
	Adjustment   string             `json:"adjustment"`
	MedicationID uuid.UUID          `json:"medication_id"`
}

func (q *Queries) UpdateMedicationModification(ctx context.Context, arg UpdateMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, updateMedicationModification,
		arg.ID,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const upsertMedication = `-- name: UpsertMedication :one
WITH input_values(id, name, description, category,alternate_names) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1::uuid
    END,
    $2::text,
    $3::text,
    $4,
    COALESCE($5::TEXT[], '{}')
  )
)
INSERT INTO medications (id, name, description, category,alternate_names)
SELECT id, name, description, category,alternate_names FROM input_values
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    description = EXCLUDED.description,
    category = EXCLUDED.category,
    alternate_names = EXCLUDED.alternate_names,
    updated_at = NOW()
RETURNING id, created_at, updated_at, name, description, alternate_names, category
`

type UpsertMedicationParams struct {
	ID             interface{} `json:"id"`
	Name           string      `json:"name"`
	Description    string      `json:"description"`
	Category       interface{} `json:"category"`
	AlternateNames []string    `json:"alternate_names"`
}

func (q *Queries) UpsertMedication(ctx context.Context, arg UpsertMedicationParams) (Medication, error) {
	row := q.db.QueryRowContext(ctx, upsertMedication,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Category,
		pq.Array(arg.AlternateNames),
	)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const upsertMedicationModification = `-- name: UpsertMedicationModification :one
INSERT INTO medication_modifications (id, category, subcategory, adjustment, medication_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE
SET category = EXCLUDED.category,
    subcategory = EXCLUDED.subcategory,
    adjustment = EXCLUDED.adjustment,
    medication_id = EXCLUDED.medication_id,
    updated_at = NOW()
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type UpsertMedicationModificationParams struct {
	ID           uuid.UUID          `json:"id"`
	Category     MedAdjCategoryEnum `json:"category"`
	Subcategory  string             `json:"subcategory"`
	Adjustment   string             `json:"adjustment"`
	MedicationID uuid.UUID          `json:"medication_id"`
}

func (q *Queries) UpsertMedicationModification(ctx context.Context, arg UpsertMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, upsertMedicationModification,
		arg.ID,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const upsertPrescription = `-- name: UpsertPrescription :one
WITH input_values(id, medication_id, dose, route, frequency, duration, instructions, renewals) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1::uuid 
    END,
    $2::uuid,
    $3,
    $4::prescription_route_enum,
    $5,
    $6,
    $7,
    $8::int
  )
)
INSERT INTO medication_prescription (id, medication_id, dose, route, frequency, duration, instructions, renewals)
SELECT id, medication_id, dose, route, frequency, duration, instructions, renewals FROM input_values
ON CONFLICT (id) DO UPDATE
SET medication_id = EXCLUDED.medication_id,
    dose = EXCLUDED.dose,
    route = EXCLUDED.route,
    frequency = EXCLUDED.frequency,
    duration = EXCLUDED.duration,
    instructions = EXCLUDED.instructions,
    renewals = EXCLUDED.renewals,
    updated_at = NOW()
RETURNING id, created_at, updated_at, medication_id, dose, route, frequency, duration, instructions, renewals
`

type UpsertPrescriptionParams struct {
	ID           interface{}           `json:"id"`
	MedicationID uuid.UUID             `json:"medication_id"`
	Dose         interface{}           `json:"dose"`
	Route        PrescriptionRouteEnum `json:"route"`
	Frequency    interface{}           `json:"frequency"`
	Duration     interface{}           `json:"duration"`
	Instructions interface{}           `json:"instructions"`
	Renewals     int32                 `json:"renewals"`
}

func (q *Queries) UpsertPrescription(ctx context.Context, arg UpsertPrescriptionParams) (MedicationPrescription, error) {
	row := q.db.QueryRowContext(ctx, upsertPrescription,
		arg.ID,
		arg.MedicationID,
		arg.Dose,
		arg.Route,
		arg.Frequency,
		arg.Duration,
		arg.Instructions,
		arg.Renewals,
	)
	var i MedicationPrescription
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MedicationID,
		&i.Dose,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}

const upsertProtoMedCategory = `-- name: UpsertProtoMedCategory :one
WITH input_values(id, protocol_id, category, comments) AS (
  VALUES (
    CASE 
      WHEN $1::uuid  = '00000000-0000-0000-0000-000000000000'
      THEN gen_random_uuid() 
      ELSE $1::uuid 
    END,
    $2::uuid,
    $3::TEXT,
    $4::text   
  )
)
INSERT INTO protocol_meds (id, protocol_id, category, comments)
SELECT id, protocol_id, category, comments FROM input_values
ON CONFLICT (id) DO UPDATE
SET protocol_id = EXCLUDED.protocol_id,
    category = EXCLUDED.category,
    comments = EXCLUDED.comments,
    updated_at = NOW()
RETURNING id, created_at, updated_at, category, comments, protocol_id
`

type UpsertProtoMedCategoryParams struct {
	ID         uuid.UUID `json:"id"`
	ProtocolID uuid.UUID `json:"protocol_id"`
	Category   string    `json:"category"`
	Comments   string    `json:"comments"`
}

func (q *Queries) UpsertProtoMedCategory(ctx context.Context, arg UpsertProtoMedCategoryParams) (ProtocolMed, error) {
	row := q.db.QueryRowContext(ctx, upsertProtoMedCategory,
		arg.ID,
		arg.ProtocolID,
		arg.Category,
		arg.Comments,
	)
	var i ProtocolMed
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Comments,
		&i.ProtocolID,
	)
	return i, err
}
