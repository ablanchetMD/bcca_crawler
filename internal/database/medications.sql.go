// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: medications.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addMedication = `-- name: AddMedication :one
INSERT INTO medications (name, description, category,alternate_names)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, name, description, alternate_names, category
`

type AddMedicationParams struct {
	Name           string   `json:"name"`
	Description    string   `json:"description"`
	Category       string   `json:"category"`
	AlternateNames []string `json:"alternate_names"`
}

func (q *Queries) AddMedication(ctx context.Context, arg AddMedicationParams) (Medication, error) {
	row := q.db.QueryRowContext(ctx, addMedication,
		arg.Name,
		arg.Description,
		arg.Category,
		pq.Array(arg.AlternateNames),
	)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const addMedicationModification = `-- name: AddMedicationModification :one
INSERT INTO medication_modifications (category, subcategory, adjustment, medication_id)
VALUES ($1, $2, $3, $4)
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type AddMedicationModificationParams struct {
	Category     string    `json:"category"`
	Subcategory  string    `json:"subcategory"`
	Adjustment   string    `json:"adjustment"`
	MedicationID uuid.UUID `json:"medication_id"`
}

func (q *Queries) AddMedicationModification(ctx context.Context, arg AddMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, addMedicationModification,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const addPrescription = `-- name: AddPrescription :one
INSERT INTO medication_prescription (medication_id, dose, route, frequency, duration, instructions, renewals)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at, updated_at, medication_id, dose, route, frequency, duration, instructions, renewals
`

type AddPrescriptionParams struct {
	MedicationID uuid.UUID             `json:"medication_id"`
	Dose         string                `json:"dose"`
	Route        PrescriptionRouteEnum `json:"route"`
	Frequency    string                `json:"frequency"`
	Duration     string                `json:"duration"`
	Instructions string                `json:"instructions"`
	Renewals     int32                 `json:"renewals"`
}

func (q *Queries) AddPrescription(ctx context.Context, arg AddPrescriptionParams) (MedicationPrescription, error) {
	row := q.db.QueryRowContext(ctx, addPrescription,
		arg.MedicationID,
		arg.Dose,
		arg.Route,
		arg.Frequency,
		arg.Duration,
		arg.Instructions,
		arg.Renewals,
	)
	var i MedicationPrescription
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MedicationID,
		&i.Dose,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}

const addPrescriptionToProtocolByCategory = `-- name: AddPrescriptionToProtocolByCategory :exec
INSERT INTO protocol_meds (protocol_id, prescription_id, category)
VALUES ($1, $2, $3)
ON CONFLICT DO NOTHING
`

type AddPrescriptionToProtocolByCategoryParams struct {
	ProtocolID     uuid.UUID            `json:"protocol_id"`
	PrescriptionID uuid.UUID            `json:"prescription_id"`
	Category       MedProtoCategoryEnum `json:"category"`
}

func (q *Queries) AddPrescriptionToProtocolByCategory(ctx context.Context, arg AddPrescriptionToProtocolByCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addPrescriptionToProtocolByCategory, arg.ProtocolID, arg.PrescriptionID, arg.Category)
	return err
}

const deleteMedication = `-- name: DeleteMedication :exec
DELETE FROM medications
WHERE id = $1
`

func (q *Queries) DeleteMedication(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteMedication, id)
	return err
}

const getMedicationByID = `-- name: GetMedicationByID :one
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE id = $1
`

func (q *Queries) GetMedicationByID(ctx context.Context, id uuid.UUID) (Medication, error) {
	row := q.db.QueryRowContext(ctx, getMedicationByID, id)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const getMedicationByName = `-- name: GetMedicationByName :one
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE name = $1
`

func (q *Queries) GetMedicationByName(ctx context.Context, name string) (Medication, error) {
	row := q.db.QueryRowContext(ctx, getMedicationByName, name)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const getMedicationModificationByID = `-- name: GetMedicationModificationByID :one
SELECT id, created_at, updated_at, category, subcategory, adjustment, medication_id FROM medication_modifications
WHERE id = $1
`

func (q *Queries) GetMedicationModificationByID(ctx context.Context, id uuid.UUID) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, getMedicationModificationByID, id)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const getMedicationModificationsByMedication = `-- name: GetMedicationModificationsByMedication :many
SELECT m.id as medication_id, mod.id as modification_id, mod.category as modification_category, mod.subcategory as modification_subcategory, mod.adjustment
FROM medication_modifications mod
JOIN medications m ON mod.medication_id = m.id
WHERE m.id = $1
`

type GetMedicationModificationsByMedicationRow struct {
	MedicationID            uuid.UUID `json:"medication_id"`
	ModificationID          uuid.UUID `json:"modification_id"`
	ModificationCategory    string    `json:"modification_category"`
	ModificationSubcategory string    `json:"modification_subcategory"`
	Adjustment              string    `json:"adjustment"`
}

func (q *Queries) GetMedicationModificationsByMedication(ctx context.Context, id uuid.UUID) ([]GetMedicationModificationsByMedicationRow, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationModificationsByMedication, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMedicationModificationsByMedicationRow{}
	for rows.Next() {
		var i GetMedicationModificationsByMedicationRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.ModificationID,
			&i.ModificationCategory,
			&i.ModificationSubcategory,
			&i.Adjustment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationModificationsByProtocol = `-- name: GetMedicationModificationsByProtocol :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, mod.id as modification_id, mod.category as modification_category, mod.subcategory as modification_subcategory, mod.adjustment
FROM medication_modifications mod
JOIN medications m ON mod.medication_id = m.id
JOIN protocol_treatment pt ON m.id = pt.medication
JOIN treatment_cycles_values tc ON pt.id = tc.protocol_treatment_id
JOIN protocol_cycles pc ON tc.protocol_cycles_id = pc.id
WHERE pc.protocol_id = $1
`

type GetMedicationModificationsByProtocolRow struct {
	MedicationID            uuid.UUID `json:"medication_id"`
	Name                    string    `json:"name"`
	Description             string    `json:"description"`
	Category                string    `json:"category"`
	AlternateNames          []string  `json:"alternate_names"`
	ModificationID          uuid.UUID `json:"modification_id"`
	ModificationCategory    string    `json:"modification_category"`
	ModificationSubcategory string    `json:"modification_subcategory"`
	Adjustment              string    `json:"adjustment"`
}

func (q *Queries) GetMedicationModificationsByProtocol(ctx context.Context, protocolID uuid.UUID) ([]GetMedicationModificationsByProtocolRow, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationModificationsByProtocol, protocolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMedicationModificationsByProtocolRow{}
	for rows.Next() {
		var i GetMedicationModificationsByProtocolRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.ModificationID,
			&i.ModificationCategory,
			&i.ModificationSubcategory,
			&i.Adjustment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedications = `-- name: GetMedications :many
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
ORDER BY name ASC
`

func (q *Queries) GetMedications(ctx context.Context) ([]Medication, error) {
	rows, err := q.db.QueryContext(ctx, getMedications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medication{}
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			pq.Array(&i.AlternateNames),
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMedicationsByCategory = `-- name: GetMedicationsByCategory :many
SELECT id, created_at, updated_at, name, description, alternate_names, category FROM medications
WHERE category = $1
ORDER BY name ASC
`

func (q *Queries) GetMedicationsByCategory(ctx context.Context, category string) ([]Medication, error) {
	rows, err := q.db.QueryContext(ctx, getMedicationsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Medication{}
	for rows.Next() {
		var i Medication
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			pq.Array(&i.AlternateNames),
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModificationsByMedication = `-- name: GetModificationsByMedication :many
SELECT id, created_at, updated_at, category, subcategory, adjustment, medication_id FROM medication_modifications
WHERE medication_id = $1
`

func (q *Queries) GetModificationsByMedication(ctx context.Context, medicationID uuid.UUID) ([]MedicationModification, error) {
	rows, err := q.db.QueryContext(ctx, getModificationsByMedication, medicationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MedicationModification{}
	for rows.Next() {
		var i MedicationModification
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.Subcategory,
			&i.Adjustment,
			&i.MedicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionByID = `-- name: GetPrescriptionByID :one
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose,p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication
WHERE p.id = $1
`

type GetPrescriptionByIDRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionByID(ctx context.Context, id uuid.UUID) (GetPrescriptionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPrescriptionByID, id)
	var i GetPrescriptionByIDRow
	err := row.Scan(
		&i.MedicationID,
		&i.Name,
		&i.Description,
		&i.Category,
		pq.Array(&i.AlternateNames),
		&i.MedicationPrescriptionID,
		&i.Dose,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}

const getPrescriptions = `-- name: GetPrescriptions :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication
ORDER BY m.name ASC
`

type GetPrescriptionsRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptions(ctx context.Context) ([]GetPrescriptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsRow{}
	for rows.Next() {
		var i GetPrescriptionsRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionsByMed = `-- name: GetPrescriptionsByMed :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication
WHERE m.id = $1
`

type GetPrescriptionsByMedRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionsByMed(ctx context.Context, id uuid.UUID) ([]GetPrescriptionsByMedRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptionsByMed, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsByMedRow{}
	for rows.Next() {
		var i GetPrescriptionsByMedRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrescriptionsByProtocolByCategory = `-- name: GetPrescriptionsByProtocolByCategory :many
SELECT m.id as medication_id, m.name, m.description, m.category,m.alternate_names, p.id as medication_prescription_id, p.dose, p.created_at,p.updated_at, p.route, p.frequency, p.duration, p.instructions, p.renewals
FROM medications m
JOIN medication_prescription p ON m.id = p.medication
JOIN protocol_meds pm ON p.id = pm.prescription_id
WHERE pm.protocol_id = $1 AND pm.category = $2
`

type GetPrescriptionsByProtocolByCategoryParams struct {
	ProtocolID uuid.UUID            `json:"protocol_id"`
	Category   MedProtoCategoryEnum `json:"category"`
}

type GetPrescriptionsByProtocolByCategoryRow struct {
	MedicationID             uuid.UUID             `json:"medication_id"`
	Name                     string                `json:"name"`
	Description              string                `json:"description"`
	Category                 string                `json:"category"`
	AlternateNames           []string              `json:"alternate_names"`
	MedicationPrescriptionID uuid.UUID             `json:"medication_prescription_id"`
	Dose                     string                `json:"dose"`
	CreatedAt                time.Time             `json:"created_at"`
	UpdatedAt                time.Time             `json:"updated_at"`
	Route                    PrescriptionRouteEnum `json:"route"`
	Frequency                string                `json:"frequency"`
	Duration                 string                `json:"duration"`
	Instructions             string                `json:"instructions"`
	Renewals                 int32                 `json:"renewals"`
}

func (q *Queries) GetPrescriptionsByProtocolByCategory(ctx context.Context, arg GetPrescriptionsByProtocolByCategoryParams) ([]GetPrescriptionsByProtocolByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptionsByProtocolByCategory, arg.ProtocolID, arg.Category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrescriptionsByProtocolByCategoryRow{}
	for rows.Next() {
		var i GetPrescriptionsByProtocolByCategoryRow
		if err := rows.Scan(
			&i.MedicationID,
			&i.Name,
			&i.Description,
			&i.Category,
			pq.Array(&i.AlternateNames),
			&i.MedicationPrescriptionID,
			&i.Dose,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Route,
			&i.Frequency,
			&i.Duration,
			&i.Instructions,
			&i.Renewals,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMedicationModification = `-- name: RemoveMedicationModification :exec
DELETE FROM medication_modifications
WHERE id = $1
`

func (q *Queries) RemoveMedicationModification(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removeMedicationModification, id)
	return err
}

const removePrescription = `-- name: RemovePrescription :exec
DELETE FROM medication_prescription
WHERE id = $1
`

func (q *Queries) RemovePrescription(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, removePrescription, id)
	return err
}

const removePrescriptionFromProtocolByCategory = `-- name: RemovePrescriptionFromProtocolByCategory :exec
DELETE FROM protocol_meds
WHERE protocol_id = $1 AND prescription_id = $2 AND category = $3
`

type RemovePrescriptionFromProtocolByCategoryParams struct {
	ProtocolID     uuid.UUID            `json:"protocol_id"`
	PrescriptionID uuid.UUID            `json:"prescription_id"`
	Category       MedProtoCategoryEnum `json:"category"`
}

func (q *Queries) RemovePrescriptionFromProtocolByCategory(ctx context.Context, arg RemovePrescriptionFromProtocolByCategoryParams) error {
	_, err := q.db.ExecContext(ctx, removePrescriptionFromProtocolByCategory, arg.ProtocolID, arg.PrescriptionID, arg.Category)
	return err
}

const updateMedicationModification = `-- name: UpdateMedicationModification :one
UPDATE medication_modifications
SET
    updated_at = NOW(),
    category = $2,
    subcategory = $3,
    adjustment = $4,
    medication_id = $5
WHERE id = $1
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type UpdateMedicationModificationParams struct {
	ID           uuid.UUID `json:"id"`
	Category     string    `json:"category"`
	Subcategory  string    `json:"subcategory"`
	Adjustment   string    `json:"adjustment"`
	MedicationID uuid.UUID `json:"medication_id"`
}

func (q *Queries) UpdateMedicationModification(ctx context.Context, arg UpdateMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, updateMedicationModification,
		arg.ID,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const upsertMedication = `-- name: UpsertMedication :one
WITH input_values(id, name, description, category,alternate_names) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1 
    END,
    $2,
    $3,
    $4,
    $5::TEXT[]
  )
)
INSERT INTO medications (id, name, description, category,alternate_names)
SELECT id, name, description, category FROM input_values
ON CONFLICT (id) DO UPDATE
SET name = EXCLUDED.name,
    description = EXCLUDED.description,
    category = EXCLUDED.category,
    alternate_names = EXCLUDED.alternate_names,
    updated_at = NOW()
RETURNING id, created_at, updated_at, name, description, alternate_names, category
`

type UpsertMedicationParams struct {
	ID             interface{} `json:"id"`
	Name           interface{} `json:"name"`
	Description    interface{} `json:"description"`
	Category       interface{} `json:"category"`
	AlternateNames []string    `json:"alternate_names"`
}

func (q *Queries) UpsertMedication(ctx context.Context, arg UpsertMedicationParams) (Medication, error) {
	row := q.db.QueryRowContext(ctx, upsertMedication,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Category,
		pq.Array(arg.AlternateNames),
	)
	var i Medication
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		pq.Array(&i.AlternateNames),
		&i.Category,
	)
	return i, err
}

const upsertMedicationModification = `-- name: UpsertMedicationModification :one
INSERT INTO medication_modifications (id, category, subcategory, adjustment, medication_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (id) DO UPDATE
SET category = EXCLUDED.category,
    subcategory = EXCLUDED.subcategory,
    adjustment = EXCLUDED.adjustment,
    medication_id = EXCLUDED.medication_id,
    updated_at = NOW()
RETURNING id, created_at, updated_at, category, subcategory, adjustment, medication_id
`

type UpsertMedicationModificationParams struct {
	ID           uuid.UUID `json:"id"`
	Category     string    `json:"category"`
	Subcategory  string    `json:"subcategory"`
	Adjustment   string    `json:"adjustment"`
	MedicationID uuid.UUID `json:"medication_id"`
}

func (q *Queries) UpsertMedicationModification(ctx context.Context, arg UpsertMedicationModificationParams) (MedicationModification, error) {
	row := q.db.QueryRowContext(ctx, upsertMedicationModification,
		arg.ID,
		arg.Category,
		arg.Subcategory,
		arg.Adjustment,
		arg.MedicationID,
	)
	var i MedicationModification
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Subcategory,
		&i.Adjustment,
		&i.MedicationID,
	)
	return i, err
}

const upsertPrescription = `-- name: UpsertPrescription :one
WITH input_values(id, medication_id, dose, route, frequency, duration, instructions, renewals) AS (
  VALUES (
    CASE 
      WHEN $1 = '00000000-0000-0000-0000-000000000000'::uuid 
      THEN gen_random_uuid() 
      ELSE $1::uuid 
    END,
    $2::uuid,
    $3,
    $4::prescription_route_enum,
    $5,
    $6,
    $7,
    $8::int
  )
)
INSERT INTO medication_prescription (id, medication_id, dose, route, frequency, duration, instructions, renewals)
SELECT id, medication_id, dose, route, frequency, duration, instructions, renewals FROM input_values
ON CONFLICT (id) DO UPDATE
SET medication_id = EXCLUDED.medication_id,
    dose = EXCLUDED.dose,
    route = EXCLUDED.route,
    frequency = EXCLUDED.frequency,
    duration = EXCLUDED.duration,
    instructions = EXCLUDED.instructions,
    renewals = EXCLUDED.renewals,
    updated_at = NOW()
RETURNING id, created_at, updated_at, medication_id, dose, route, frequency, duration, instructions, renewals
`

type UpsertPrescriptionParams struct {
	ID           interface{}           `json:"id"`
	MedicationID uuid.UUID             `json:"medication_id"`
	Dose         interface{}           `json:"dose"`
	Route        PrescriptionRouteEnum `json:"route"`
	Frequency    interface{}           `json:"frequency"`
	Duration     interface{}           `json:"duration"`
	Instructions interface{}           `json:"instructions"`
	Renewals     int32                 `json:"renewals"`
}

func (q *Queries) UpsertPrescription(ctx context.Context, arg UpsertPrescriptionParams) (MedicationPrescription, error) {
	row := q.db.QueryRowContext(ctx, upsertPrescription,
		arg.ID,
		arg.MedicationID,
		arg.Dose,
		arg.Route,
		arg.Frequency,
		arg.Duration,
		arg.Instructions,
		arg.Renewals,
	)
	var i MedicationPrescription
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MedicationID,
		&i.Dose,
		&i.Route,
		&i.Frequency,
		&i.Duration,
		&i.Instructions,
		&i.Renewals,
	)
	return i, err
}
